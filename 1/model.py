# model.py

# импортируем необходимые библиотеки
import tensorflow as tf # библиотека для работы с нейронными сетями
from tensorflow import keras # высокоуровневый API для работы с нейронными сетями
import numpy as np # библиотека для работы с числовыми данными

def train_placement_model(data):
  # функция для обучения модели для выбора каналов и времени размещения рекламы
  # принимает на вход данные о пользовательском поведении и рынке
  # использует нейронную сеть с несколькими скрытыми слоями и softmax-активацией на выходном слое
  # возвращает обученную модель keras
  
  # определение архитектуры модели
  model = keras.Sequential([
    keras.layers.Dense(64, activation='relu', input_shape=(data.shape[1],)), # входной слой с количеством нейронов равным количеству признаков в данных
    keras.layers.Dense(32, activation='relu'), # скрытый слой с количеством нейронов равным половине от предыдущего слоя
    keras.layers.Dense(16, activation='relu'), # скрытый слой с количеством нейронов равным половине от предыдущего слоя
    keras.layers.Dense(4, activation='softmax') # выходной слой с количеством нейронов равным количеству каналов (4) и softmax-активацией для получения вероятностей
  ])
  
  # компиляция модели
  model.compile(optimizer='adam', # оптимизатор для обновления весов модели
                loss='sparse_categorical_crossentropy', # функция потерь для многоклассовой классификации
                metrics=['accuracy']) # метрика для оценки качества модели
  
  # разделение данных на обучающую и тестовую выборки
  X = data[:, :-1] # все признаки, кроме последнего (канал)
  y = data[:, -1] # последний признак (канал)
  X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) # разбиваем данные на обучающую (80%) и тестовую (20%) выборки
  
  # обучение модели на обучающей выборке
  model.fit(X_train, y_train, epochs=10) # запускаем процесс обучения на 10 эпохах
  
  # оценка модели на тестовой выборке
  model.evaluate(X_test, y_test) # выводим потерю и точность модели на тестовых данных
  
  return model

def train_format_model(data):
  # функция для обучения модели для выбора формата рекламы
  # принимает на вход данные о пользовательском поведении и рынке
  # использует нейронную сеть с несколькими скрытыми слоями и softmax-активацией на выходном слое
  # возвращает обученную модель keras
  
  # определение архитектуры модели
  model = keras.Sequential([
    keras.layers.Dense(64, activation='relu', input_shape=(data.shape[1],)), # входной слой с количеством нейронов равным количеству признаков в данных
    keras.layers.Dense(32, activation='relu'), # скрытый слой с количеством нейронов равным половине от предыдущего слоя
    keras.layers.Dense(16, activation='relu'), # скрытый слой с количеством нейронов равным половине от предыдущего слоя
    keras.layers.Dense(3, activation='softmax') # выходной слой с количеством нейронов равным количеству форматов (3) и softmax-активацией для получения вероятностей
  ])
  
  # компиляция модели
  model.compile(optimizer='adam', # оптимизатор для обновления весов модели
                loss='sparse_categorical_crossentropy', # функция потерь для многоклассовой классификации
                metrics=['accuracy']) # метрика для оценки качества модели
  
  # разделение данных на обучающую и тестовую выборки
  X = data[:, :-1] # все признаки, кроме последнего (формат)
  y = data[:, -1] # последний признак (формат)
  X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2) # разбиваем данные на обучающую (80%) и тестовую (20%) выборки
  
  # обучение модели на обучающей выборке
  model.fit(X_train, y_train, epochs=10) # запускаем процесс обучения на 10 эпохах
  
  # оценка модели на тестовой выборке
  model.evaluate(X_test, y_test) # выводим потерю и точность модели на тестовых данных
  
  return model

def train_bid_model(data):
  # функция для обучения модели для выбора ставок для рекламы
  # принимает на вход данные о пользовательском поведении и рынке
  # использует нейронную сеть с несколькими скрытыми слоями и линейной активацией на выходном слое
  # возвращает обученную модель keras
  
  # определение архитектуры модели
  model = keras.Sequential([
    keras.layers.Dense(64, activation='relu', input_shape=(data.shape[1],)), # входной слой с количеством нейронов равным количеству признаков в данных
    keras.layers.Dense(32, activation='relu'), # скрытый слой с количеством нейронов равным половине от предыдущего слоя
    keras.layers.Dense(16, activation='relu'), # скрытый слой с количеством нейронов равным половине от предыдущего слоя
    keras.layers.Dense(1, activation='linear') # выходной слой с одним нейроном и линейной активацией для получения ставки
  ])
  
  # компиляция модели
  model.compile(optimizer='adam', # оптимизатор для обновления весов модели
                loss='mse', # функция потерь для регрессии - среднеквадратичная ошибка
                metrics=['mae']) # метрика для оценки качества модели - средняя абсолютная ошибка
  
  # разделение данных на обучающую и тестовую выборки
  X = data[:, :-1] # все признаки, кроме последнего (ставка)
  y = data[:, -1] # последний признак (ставка)
  X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2
